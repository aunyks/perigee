<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Perigee Demo Level 0</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="/css/pico.min.css">
    <link rel="stylesheet" href="/css/perigee.css">
    <link rel="stylesheet" href="/css/virtual-joystick.css">
    <script defer src="/js/components/modal.js"></script>
    <style>
      html,
      body {
        overflow: hidden;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }

      dialog {
        user-select: auto;
        touch-action: auto;
      }

      .hud.input {
        -webkit-user-select: none;
        user-select: none;
        touch-action: auto;
      }

      #virtual-jump-button-container {
        bottom: 180px;
        right: 20px;
      }

      #virtual-jump-button {
        fill: rgba(48, 48, 48, 0.8);
        stroke: white;
        stroke-width: 5px;
        user-select: none;
        position: absolute;
      }

      #virtual-jump-button.active {
        fill: rgba(48, 48, 48, 0.2);
      }

      #virtual-crouch-button-container {
        bottom: 105px;
        right: 70px;
      }

      #virtual-crouch-button {
        fill: rgba(48, 48, 48, 0.8);
        stroke: white;
        stroke-width: 5px;
        user-select: none;
        position: absolute;
      }

      #virtual-crouch-button.active {
        fill: rgba(48, 48, 48, 0.2);
      }

      .controls-tutorial-section-head {
        margin-bottom: 0.5rem;
      }

      #pause-button {
        position: absolute;
        top: 40px;
        right: 30px;
      }

    </style>
  </head>

  <body>
    <p id="ad-announcer" visually-hidden="true" aria-live="polite"></p>
    <div id="stacking-container">
      <div id="loading-container">
        <div>
          <h1 aria-busy="true">Loading world</h1>
        </div>
      </div>
      <div id="scene-container" class="hidden">
        <canvas id="scene-canvas"></canvas>
        <svg role="button" id="pause-button" width="50" height="50" class="hud input" viewBox="0 0 100 100"
          xmlns="http://www.w3.org/2000/svg">
          <rect width="100" height="100" rx="20" fill="black" />
          <rect x="26" y="27" width="16" height="46" fill="white" />
          <rect x="58" y="27" width="16" height="46" fill="white" />
        </svg>
        <svg id="virtual-joystick-container" class="hud input" width="160" viewBox="0 0 368 368"
          xmlns="http://www.w3.org/2000/svg">
          <circle cx="184" cy="184" r="110" />
          <circle id="virtual-joystick" cx="184" cy="184" r="100" />
        </svg>
        <svg id="virtual-jump-button-container"
          ontouchstart="document.getElementById('virtual-jump-button').classList.add('active')"
          ontouchend="document.getElementById('virtual-jump-button').classList.remove('active')" class="hud input"
          width="80" viewBox="0 0 368 368" xmlns="http://www.w3.org/2000/svg">
          <circle cx="184" cy="184" r="184"></circle>
          <circle id="virtual-jump-button" cx="184" cy="184" r="174"></circle>
          <text x="100" y="210" font-size="4.5em" fill="white" style="user-select: none;">Jump</text>
        </svg>
        <!-- <svg id="virtual-crouch-button-container"
          ontouchstart="document.getElementById('virtual-crouch-button').classList.add('active')"
          ontouchend="document.getElementById('virtual-crouch-button').classList.remove('active')" class="hud input"
          width="80" viewBox="0 0 368 368" xmlns="http://www.w3.org/2000/svg">
          <circle cx="184" cy="184" r="184"></circle>
          <circle id="virtual-crouch-button" cx="184" cy="184" r="174"></circle>
          <text x="70" y="210" font-size="4.5em" fill="white" style="user-select: none;">Crouch</text>
        </svg> -->
      </div>
    </div>
    <dialog role="dialog" aria-labelledby="intro-title" aria-describedby="intro-content" id="intro-modal"
      can-exit="false">
      <article>
        <h1 id="intro-title">Demo Level</h1>
        <p id="intro-content" style="margin-bottom: 1rem;"> This is the level I use to test everything in the game. This
          is a super early rough draft. Let me know if there's something you'd like to see or if something could be made
          better!</p>
        <details style="margin-bottom: 1rem;">
          <summary>See Controls</summary>
          <div tabindex="0">
            <h3 class="controls-tutorial-section-head">Pause</h3>
            <ul>
              <li>Escape (Keyboard)</li>
              <li>Start (Controller)</li>
              <li>On-Screen Button (Touch Screen)</li>
            </ul>
            <h3 class="controls-tutorial-section-head">Move</h3>
            <ul>
              <li>WASD (Keyboard)</li>
              <li>Left Stick (Controller)</li>
              <li>On-Screen Stick (Touch Screen)</li>
            </ul>
            <h3 class="controls-tutorial-section-head">Crouch</h3>
            <ul>
              <li>C (Keyboard)</li>
              <li>Button Pad East (Controller)</li>
              <li>On-Screen Crouch Button (Touch Screen)</li>
            </ul>
            <h3 class="controls-tutorial-section-head">Jump</h3>
            <ul>
              <li>Spacebar (Keyboard)</li>
              <li>Button Pad South (Controller)</li>
              <li>On-Screen Jump Button (Touch Screen)</li>
            </ul>
            <h3 class="controls-tutorial-section-head">Wallrun</h3>
            <p>Jump into a wall to enter wallrun. Jump while wallrunning to exit.</p>
          </div>
        </details>
        <button id="start-game-button">Start Game</button>
      </article>
    </dialog>
    <dialog role="dialog" aria-label="Pause menu" id="pause-modal" can-exit="false">
      <article>
        <button id="resume-game-button">Resume</button>
        <button id="restart-level-button">Restart Level</button>
        <button id="settings-button">Settings</button>
        <button id="quit-game-button">Quit Game</button>
      </article>
    </dialog>
    <dialog role="dialog" aria-label="Confirm restart" id="restart-level-conf-modal" can-exit="false">
      <article>
        <h2>Are you sure?</h2>
        <p style="margin-bottom: 1em;">This will restart the entire level and ignore your current progress.</p>
        <div class="grid">
          <button id="restart-level-conf-button">Yes</button>
          <button id="restart-level-deny-button">No</button>
        </div>
      </article>
    </dialog>
    <dialog role="dialog" aria-label="Settings" id="settings-modal" can-exit="false">
      <article>
        <h2>Master Volume</h2>
        <input id="master-volume-slider" type="range" min="0" max="100" value="100" />
        <h2>Horizontal Look Sensitivity</h2>
        <input id="horiz-sens-slider" type="range" min="1" max="10" step="1" value="5" list="horiz-sens-list" />
        <datalist id="horiz-sens-list">
          <option>1</option>
          <option>2</option>
          <option>3</option>
          <option>4</option>
          <option>5</option>
          <option>6</option>
          <option>7</option>
          <option>8</option>
          <option>9</option>
          <option>10</option>
        </datalist>
        <h2>Vertical Look Sensitivity</h2>
        <input id="vert-sens-slider" type="range" min="1" max="10" step="1" value="5" list="vert-sens-list" />
        <datalist id="vert-sens-list">
          <option>1</option>
          <option>2</option>
          <option>3</option>
          <option>4</option>
          <option>5</option>
          <option>6</option>
          <option>7</option>
          <option>8</option>
          <option>9</option>
          <option>10</option>
        </datalist>
        <h2>Show Performance Stats</h2>
        <input id="perf-stats-toggle" style="margin-bottom:2em;" type="checkbox" />
        <h2>Show Debug Tools</h2>
        <input id="debug-tools-toggle" style="margin-bottom:2em;" type="checkbox" />
        <button id="settings-back-button">Back</button>
      </article>
    </dialog>
    <dialog role="alertdialog" id="error-modal" can-exit="false">
      <article>
        <h2>An error occurred while loading assets.</h2>
        <a role="button" href="" style="width: 100%;">Try again</a>
      </article>
    </dialog>
    <script src="/js/misc/mobile-safari-disable-pinch-zoom.js"></script>
    <script type="module">
      import {
        Audio,
        Color,
        Object3D,
        AmbientLight,
        PerspectiveCamera,
        Scene,
        WebGLRenderer,
        AnimationMixer,
        AnimationClip,
        AudioListener,
        ColorManagement,
        LoopRepeat,
        Group,
        MeshBasicMaterial,
        SphereGeometry,
        Vector2,
        ACESFilmicToneMapping,
        sRGBEncoding,
        CapsuleGeometry,
        BoxGeometry,
        Euler,
        Mesh,
        InstancedMesh,
        BackSide
      } from '/js/graphics/three.module.js'
      import {
        EffectComposer
      } from '/js/graphics/postprocessing/EffectComposer.js'
      import {
        RenderPass
      } from '/js/graphics/postprocessing/RenderPass.js'
      import {
        UnrealBloomPass
      } from '/js/graphics/postprocessing/UnrealBloomPass.js'
      import {
        ShaderPass
      } from '/js/graphics/postprocessing/ShaderPass.js'
      import {
        SMAAPass
      } from '/js/graphics/postprocessing/SMAAPass.js'
      import {
        FXAAShader
      } from '/js/graphics/postprocessing/shaders/FXAAShader.js'
      import PointerLockInput from '/js/input/pointerlock.module.js'
      import KeyboardInput from '/js/input/keyboard.module.js'
      import VirtualJoystickInput from '/js/input/virtual-joystick.module.js'
      import VirtualJumpBtnInput from '/js/input/virtual-jumpbtn.module.js'
      import VirtualCrouchBtnInput from '/js/input/virtual-crouchbtn.module.js'
      import TouchInput from '/js/input/touch.module.js'
      import GamePadInput from '/js/input/gamepad.module.js'
      import { GameInput, processInputs, collectInputsIntoSimulation } from '/js/input/game-input.module.js'
      import { Sim } from '/js/levels/0/Sim.module.js'
      import {
        randomIntFromZero,
        bindAssistiveDeviceAnnouncer,
      } from '/js/misc/utils.module.js'
      import {
        promiseLoadAudioBuffer,
        promiseLoadGltf,
        promiseParseGltf,
        promiseLoadTexture
      } from '/js/graphics/three-ext/utils.module.js'
      import TerrainInstancedMesh from '/js/graphics/three-ext/terrain-instancedmesh.module.js'
      import SkyDome from '/js/graphics/prefabs/skydome.module.js'
      import Sun from '/js/graphics/prefabs/sun.module.js'
      import Stats from '/js/debug/stats.module.js'
      import GUI from '/js/debug/lil-gui.module.js'

      const loadingContainer = document.getElementById('loading-container')
      const sceneContainer = document.getElementById('scene-container')
      const sceneCanvas = document.getElementById('scene-canvas')

      const adAnnounce = bindAssistiveDeviceAnnouncer(document.getElementById('ad-announcer'))
      adAnnounce(loadingContainer.innerText)

      const simulation = await Sim.fromWasmBinary(
        '/wasm/levels/0/sim.wasm'
      )

      const assetsToLoad = [
        simulation,
        // Visuals
        promiseParseGltf(simulation.getSceneGltfBytes()),
        promiseLoadGltf('/gltf/player/player-camera.glb'),
        promiseParseGltf(simulation.getPlayerGltfBytes()),
        // Audio
        promiseLoadAudioBuffer('/audio/player/footstep.mp3'),
        promiseLoadAudioBuffer('/audio/player/jump.mp3'),
        promiseLoadAudioBuffer('/audio/player/slide.mp3')
      ]

      // Load all assets and then we're ready to load the scene
      Promise.all(assetsToLoad).then(([
        sim,
        // Visuals
        sceneGltf,
        animatedCameraGltf,
        playerModelGltf,
        // Audio
        footstepAudioBuffer,
        jumpAudioBuffer,
        slideAudioBuffer
      ]) => {
        loadingContainer.remove()
        sceneContainer.classList.remove('hidden')

        const perfStatistics = new Stats()
        document.body.appendChild(perfStatistics.dom)

        // Settings values
        const masterVolumeSlider = document.getElementById('master-volume-slider')
        const horizSensSlider = document.getElementById('horiz-sens-slider')
        const vertSensSlider = document.getElementById('vert-sens-slider')
        const perfStatsCheckbox = document.getElementById('perf-stats-toggle')
        const debugToolsCheckbox = document.getElementById('debug-tools-toggle')

        const settings = {
          sim: {
            leftRightLookSensitivity: parseInt(horizSensSlider.value),
            upDownLookSensitivity: parseInt(vertSensSlider.value)
          },
          interface: {
            masterVolume: parseFloat(masterVolumeSlider.value) / 100,
            perfStatisticsEnabled: perfStatsCheckbox.checked,
            debugToolsEnabled: debugToolsCheckbox.checked,
          }
        }
        sim.setLeftRightLookSensitivity(settings.sim.leftRightLookSensitivity)
        sim.setUpDownLookSensitivity(settings.sim.upDownLookSensitivity)
        if(settings.interface.perfStatisticsEnabled) {
          perfStatistics.showPanel()
        }

        masterVolumeSlider.addEventListener('change', (e) => {
          settings.interface.masterVolume = parseFloat(e.target.value) / 100
        })

        horizSensSlider.addEventListener('change', (e) => {
          sim.setLeftRightLookSensitivity(parseInt(e.target.value))
        })

        vertSensSlider.addEventListener('change', (e) => {
          sim.setUpDownLookSensitivity(parseInt(e.target.value))
        })

        perfStatsCheckbox.addEventListener('change', (e) => {
          const checked = e.currentTarget.checked
          settings.interface.perfStatisticsEnabled = checked

          if(checked) {
            perfStatistics.showPanel()
          } else {
            perfStatistics.hideAllPanels()
          }
        })

        let debugGui = null
        debugToolsCheckbox.addEventListener('change', (e) => {
          const checked = e.currentTarget.checked
          settings.interface.debugToolsEnabled = checked

          if(checked) {
            debugGui = new GUI()
            debugGui.add(document, 'title')
          } else {
            debugGui.destroy()
          }
        })

        const renderer = new WebGLRenderer({
          canvas: sceneCanvas,
          antialias: window.devicePixelRatio > 1 ? false : true,
        })
        // We need this since we're drawing twice
        renderer.autoClear = false
        renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight)
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.physicallyCorrectLights = true
        ColorManagement.enabled = true
        ColorManagement.legacyMode = false
        renderer.toneMappingExposure = 1
        renderer.outputEncoding = sRGBEncoding
        renderer.toneMapping = ACESFilmicToneMapping
        sceneContainer.append(renderer.domElement)

        // Prepare our scene
        const mainScene = new Scene()

        // Create our background environment
        const backgroundEnvironment = new Group()
        backgroundEnvironment.add(new SkyDome())
        const sun = new Sun(null, 0.4)
        sun.pivot.rotation.set(Math.PI / 6, 0, 0, 'YXZ')
        backgroundEnvironment.add(sun)
        mainScene.add(backgroundEnvironment)

        const playerHeight = 1.83
        const playerRadius = 0.4
        const playerMesh = new Mesh(new CapsuleGeometry(playerRadius, playerHeight - (playerRadius * 2)), new MeshBasicMaterial({ color: 0xffff00, wireframe: true }))
        // mainScene.add(playerMesh)

        sceneGltf.scene.traverse((obj) => {
          if(obj.isMesh && !obj.userData.simSettings.graphics.enabled) {
            obj.removeFromParent()
            obj.geometry.dispose()
            obj.material.dispose()
            obj = undefined
          }
        })

        mainScene.add(sceneGltf.scene)

        const playerMixer = new AnimationMixer(playerModelGltf.scene)
        mainScene.add(playerModelGltf.scene)

        mainScene.add(new AmbientLight())

        const animatedCamera = animatedCameraGltf.cameras[0]
        animatedCamera.fov = 35
        animatedCamera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight
        animatedCamera.near = 0.01
        animatedCamera.far = 1000
        const cameraRig = new Object3D()
        cameraRig.add(animatedCameraGltf.scene)
        mainScene.add(cameraRig)
        const cameraMixer = new AnimationMixer(animatedCameraGltf.scene)
        const [cameraIdleAnimation, cameraRunningAnimation] = animatedCameraGltf.animations

        const audioListener = new AudioListener()
        animatedCamera.add(audioListener)

        const footstepAudio = (new Audio(audioListener)).setBuffer(footstepAudioBuffer)
        const jumpAudio = (new Audio(audioListener)).setBuffer(jumpAudioBuffer)
        const slideAudio = (new Audio(audioListener)).setBuffer(slideAudioBuffer)

        let isWallRunning = false

        sim.events.on('PLAY_2D_AUDIO', (audioName) => {
          switch(audioName) {
            case 'PLAYER_STEP': {
              if(footstepAudio.isPlaying) {
                footstepAudio.stop()
              }
              footstepAudio.detune = 100 * (randomIntFromZero(8) - 4)
              footstepAudio
                .setVolume(settings.interface.masterVolume * (isWallRunning ? 0.6 : 0.75))
                .play()
              // .onEnded = () => { console.log('step taken') }
              break
            }
            case 'PLAYER_JUMP': {
              if(jumpAudio.isPlaying) {
                jumpAudio.stop()
              }
              jumpAudio.detune = 100 * (randomIntFromZero(2) - 1)
              jumpAudio
                .setVolume(settings.interface.masterVolume * 0.8)
                .play()
              break
            }
            default: { }
          }
        })

        sim.events.on('LOOP_2D_AUDIO', (audioName) => {
          switch(audioName) {
            case 'PLAYER_SLIDE': {
              if(slideAudio.isPlaying) {
                slideAudio.stop()
              }
              slideAudio.detune = 100 * (randomIntFromZero(4) - 2)
              slideAudio
                .setVolume(settings.interface.masterVolume * 0.75)
                .setLoop(true)
                .play()
              break
            }
            case 'PLAYER_WALLRUN': {
              isWallRunning = true
              if(slideAudio.isPlaying) {
                slideAudio.stop()
              }
              slideAudio.detune = 100 * (randomIntFromZero(4) - 2)
              slideAudio
                .setVolume(settings.interface.masterVolume * 0.75)
                .setLoop(true)
                .play()
              break
            }
            default: { }
          }
        })

        sim.events.on('STOP_2D_AUDIO', (audioName) => {
          switch(audioName) {
            case 'PLAYER_WALLRUN': {
              isWallRunning = false
              if(slideAudio.isPlaying) {
                slideAudio.stop()
              }
              break
            }
            case 'PLAYER_SLIDE': {
              if(slideAudio.isPlaying) {
                slideAudio.stop()
              }
              break
            }
            default: { }
          }
        })

        const ANIM_FADE_DURATION = 0.15

        sim.events.on('LOOP_ANIMATION', (sceneObj, animName) => {
          let mixer = null
          switch(sceneObj) {
            case 'PLAYER': {
              mixer = playerMixer
              break;
            }
            default: {
              // do nothing
            }
          }

          if(mixer !== null) {
            const anim = mixer.clipAction(AnimationClip.findByName(playerModelGltf.animations, animName).optimize())
            if(anim !== null) {
              anim.reset().fadeIn(ANIM_FADE_DURATION).play()
            }
          }
        })

        sim.events.on('STOP_ANIMATION', (sceneObj, animName) => {
          let mixer = null
          switch(sceneObj) {
            case 'PLAYER': {
              mixer = playerMixer
              break;
            }
            default: {
              // do nothing
            }
          }

          if(mixer !== null) {
            const anim = mixer.clipAction(AnimationClip.findByName(playerModelGltf.animations, animName))
            if(anim !== null) {
              anim.fadeOut(ANIM_FADE_DURATION)
            }
          }
        })

        sim.events.on('AD_ANNOUNCEMENT', (msg) => {
          adAnnounce(msg)
        })

        // Higher importance inputs should be later in the list
        const inputs = [
          new PointerLockInput(document.getElementById('scene-container')),
          new KeyboardInput(document.body),
          new VirtualJoystickInput(document.getElementById('virtual-joystick')),
          new TouchInput(sceneCanvas),
          new VirtualJumpBtnInput(document.getElementById('virtual-jump-button-container')),
          // new VirtualCrouchBtnInput(document.getElementById('virtual-crouch-button-container')),
          new GamePadInput(0),
        ]
        const gameInput = new GameInput()

        document.getElementById('pause-button').addEventListener('click', () => {
          pauseGame()
        })

        let gameLoopContext = null
        let lastTimestamp = null
        let deltaT = 0
        let activeCamera = animatedCamera
        let gamepadUsed = false

        const postProcessComposer = new EffectComposer(renderer)
        postProcessComposer.addPass(new RenderPass(mainScene, activeCamera))
        postProcessComposer.addPass(new UnrealBloomPass(new Vector2(sceneContainer.offsetWidth, sceneContainer.offsetHeight), 0.7, 3, 0.99))
        postProcessComposer.addPass(new ShaderPass(FXAAShader))

        function onGameLoopTick(tFrame) {
          deltaT = Math.abs(tFrame - lastTimestamp)
          perfStatistics.begin()
          if(deltaT < 90) {
            const gamepadReady = inputs[inputs.length - 1].ready()
            if(gamepadReady) {
              document.querySelectorAll('.hud.input').forEach(hudInputElement => {
                hudInputElement.style.display = 'none'
              })
              gamepadUsed = true
            } else {
              if(gamepadUsed && inputs[3].ready()) {
                document.querySelectorAll('.hud.input').forEach(hudInputElement => {
                  hudInputElement.style.display = 'block'
                })
              }
            }

            const shouldPause = inputs[1].ready() && inputs[1].escapePressed()
              || gamepadReady && inputs[inputs.length - 1].startBtnPressed()
            if(shouldPause) {
              pauseGame()
              return
            }

            processInputs(inputs, gameInput)
            collectInputsIntoSimulation(gameInput, sim)

            const deltaSeconds = deltaT / 1000
            sim.step(deltaSeconds)
            const [camGlobalRotation, camGlobalTranslation] = sim.cameraGlobalIsometry()
            cameraRig.position.fromArray(camGlobalTranslation)
            cameraRig.quaternion.fromArray(camGlobalRotation)
            cameraMixer.update(deltaSeconds)

            playerMixer.update(deltaSeconds)

            const [playerRotation, playerTranslation] = sim.playerBodyIsometry()
            playerMesh.position.fromArray(playerTranslation)
            playerMesh.quaternion.fromArray(playerRotation)
            playerModelGltf.scene.position.fromArray(playerTranslation)
            playerModelGltf.scene.quaternion.fromArray(playerRotation)

            sceneGltf.scene.traverse((obj) => {
              if(obj.isMesh && !obj.userData.simSettings.physics.isAnonymous) {
                const propName = obj.userData.name
                const [propRot, propTrans] = sim.propIsometry(propName)
                obj.position.fromArray(propTrans)
                obj.quaternion.fromArray(propRot)
              }
            })

            // Make sure the background environment follows the camera. We don't have to worry
            // about it occluding anything because every object in it has a low render order 
            // and material depth test turned off
            activeCamera.getWorldPosition(backgroundEnvironment.position)

            postProcessComposer.render(deltaSeconds)
          }
          perfStatistics.end()
          lastTimestamp = tFrame
          gameLoopContext = window.requestAnimationFrame(onGameLoopTick)
        }

        function startGameplay() {
          audioListener.context.resume()
          sceneCanvas.focus()
          adAnnounce('Gameplay started')

          // Somehow this subtraction prevents abortions on gameplay resume
          // Using 45 because it's equidistant between 30fps (on lower end devices) 
          // and 60 fps
          lastTimestamp = window.performance.now()
          onGameLoopTick(window.performance.now())
        }

        function stopGameplay() {
          window.cancelAnimationFrame(gameLoopContext)
          adAnnounce('Gameplay stopped')
        }

        function resetCameraProjection() {
          const aspect = window.innerWidth / window.innerHeight
          activeCamera.aspect = aspect
          activeCamera.updateProjectionMatrix()
          renderer.setSize(window.innerWidth, window.innerHeight)
        }
        window.addEventListener('resize', resetCameraProjection, false)

        function pauseGame() {
          stopGameplay()
          toggleModal(modalWithId('pause-modal'))
          adAnnounce('Pause menu opened')
        }

        function resumeGame() {
          toggleModal(modalWithId('pause-modal'))
          startGameplay()
        }

        function resetGame() {
          sim.reset()
          adAnnounce('Game reset')
        }

        document.body.addEventListener('keydown', e => {
          if(e.key === 'Escape') {
            pauseGame()
          }
        })

        document.getElementById('resume-game-button').addEventListener('click', () => {
          resumeGame()
        })

        document.getElementById('restart-level-button').addEventListener('click', e => {
          toggleModal(modalWithId('pause-modal'))
          toggleModal(modalWithId('restart-level-conf-modal'))
        })

        document.getElementById('restart-level-conf-button').addEventListener('click', e => {
          toggleModal(modalWithId('restart-level-conf-modal'))
          resetGame()
          startGameplay()
        })

        document.getElementById('restart-level-deny-button').addEventListener('click', e => {
          toggleModal(modalWithId('restart-level-conf-modal'))
          toggleModal(modalWithId('pause-modal'))
        })

        document.getElementById('settings-button').addEventListener('click', () => {
          toggleModal(modalWithId('pause-modal'))
          toggleModal(modalWithId('settings-modal'))
        })

        document.getElementById('settings-back-button').addEventListener('click', () => {
          toggleModal(modalWithId('settings-modal'))
          toggleModal(modalWithId('pause-modal'))
        })

        document.getElementById('quit-game-button').addEventListener('click', () => {
          window.location.href = '/'
        })

        let levelStarted = false
        document.addEventListener("visibilitychange", function () {
          if(document.visibilityState !== 'visible' && levelStarted) {
            pauseGame()
          }
        })

        sim.initialize()
        toggleModal(modalWithId('intro-modal'))
        const startBtn = document.getElementById('start-game-button')
        startBtn.addEventListener('click', () => {
          resetCameraProjection()
          startGameplay()
          toggleModal(modalWithId('intro-modal'))
          levelStarted = true
        })
        adAnnounce('Loading complete')
      }).catch((e) => {
        console.error(e)
        toggleModal(modalWithId('error-modal'))
      })
    </script>
  </body>

</html>
